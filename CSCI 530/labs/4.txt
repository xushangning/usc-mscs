1. buf is located at 0xbffceb26. ebp's value is 0xbffceb28, so the address is located at 0xbffceb2c. The separation is now 0xbffceb2c - 0xbffceb26 = 6 bytes.
2. a. 24
    b. Because there is separation between buf and critical program data. Critical program data will only be overridden when all the separation space is overridden.
    c. You were 1 byte off because strcpy would copy the null character in addition to the string contents. "Segmentation fault" happened because when a string of 24 characters was copied into buf, an additional null character was copied and overrode the least significant byte of the saved ebp on the stack and made the saved ebp an invalid address. At the end of fn function, ebp restored to that invalid address. At the end of the main function, the leave instruction set esp to ebp, pointing the stack to invalid memory space. The program popped random data in memory from the invalid memory space, returned to that address and tried to continue execution, leading to the problem.
3. Both stack buffer and the heartbleed flaw involves writing data to buffer smaller than the data. The consequences of two flaws are different. In buffer overflow, the strcpy function will always insert a null character and the buffer itself is never printed in the code, so information disclosure is more difficult than heartbleed, where the null character for the buffer can be overridden by a long string and the overflowing buffer is printed.
4. I would use the flaw to try to steal the server's private key in TLS and then used the private key to eavesdrop HTTPS connections to steal user passwords.
